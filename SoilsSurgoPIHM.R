#################### Program to create the soils File in PIHM from Data in SSurgo and other resources##################
################# Felipe Montes ##########################
################# 2015 11 13 ############################
################# REvised 2017/09/29 ####################

###############################################################################################################
#                          Loading Packages and setting up working directory                        
###############################################################################################################



#  Tell the program where the package libraries are  #####################


.libPaths("C:/Felipe/Sotware&Coding/R_Library/library")  ;

#  Set Working directory

setwd('C:\\Felipe\\PIHM-CYCLES\\PIHM\\PIHM_R_Scripts\\MM_PIHM_inputs')   

#  Windows.Directory<-gsub("\\\\", "/", readClipboard())
#  C:\Felipe\PIHM-CYCLES\PIHM\PIHM_Felipe\CNS\Manhantango\HydroTerreFullManhantango\HansYostDeepCreek\Aug2920171550

#  C:/Felipe/PIHM-CYCLES/PIHM/PIHM_Felipe/CNS/WE-38/WE38_Files_PIHM_Cycles20170208/SWATPIHMRcode 


####### Store the name of the project to read and write files more easily #############

#Project<-"MergeVectorLayer000_q30_a200000"   ;

Project<-"DataModel" ;



load(paste0('./',Project,'/PIHMInputsR.RData'));



######## Store the name of the directory whre the modified MM-PIHM inputs are to be stored


#dir.create(Project);


RevisedOutputs.dir<-paste0('./',Project,'/') ;




# Create the path to read the input files by pasting RevisedOutputs.dir and the Project name together with the file ".name" ie ".mesh"

inputfile.name<-paste0(RevisedOutputs.dir,Project) ;

########### Install packages  #####################


# install.packages('raster', dep=TRUE)
# install.packages('plyr', dep=TRUE)
# install.packages('Hmisc', dep=TRUE)
# install.packages('soilDB', dep=TRUE) # stable version from CRAN + dependencies
# install.packages("soilDB", repos="http://R-Forge.R-project.org") # most recent copy from r-forge
# install.packages("SSOAP", repos = "http://www.omegahat.org/R", type="source") # SSOAP and XMLSchema
# install.packages("foreign")
# install.packages("httr", dep=TRUE)
# install.packages("rgdal", dep = TRUE)
# install.packages("raster", dep = TRUE)
# install.packages("rgeos", dep = TRUE)
# install.packages("RColorBrewer")
# install.packages("latticeExtra")A
# install.packages("reshape")
# install.packages("dplyr")
# install.packages("aqp")

########### Call the library packages needed for the program to work #############

# load libraries
library(Hmisc) ;
library(plyr) ;
library(dplyr)  ;
library(soilDB) ;
library(raster) ;
library(aqp) ;
library(sp) ;
library(rgdal) ;
library(raster) ;
library(rgeos) ; 
library(lattice) ;
library(MASS) ;
library(RColorBrewer) ;
library(ggplot2)  ;
#library(tmap) ;
library(tidyr)  ;
library(devtools) ;
library(stats)

   


# ########################## import the raster file with the GSSURGO Data for the watershed in PIHM ####################
# 
# 
# Manhatango_GSSURGO<- raster('C:\\Felipe\\PIHM-CYCLES\\PIHM\\PIHM_Felipe\\CNS\\Manhantango\\gssurgo_g_pa\\GSSURGO_PA_TIFF\\MahatangoGSSG1.tif') ;
# 
# # generate a RAT via raster package functionality
# Manhatango_GSSURGO <- ratify(Manhatango_GSSURGO) ;
# 
# # extract RAT to a data.frame
# MUKEYS <- levels(Manhatango_GSSURGO)[[1]] ;
# 
# ##### The File above contains all the mukeys in the GSSURGO raster data enclosed by the Mahatango wateshed boundaries. This 
# ##### includes all Map units in the map. In order to better select soil properties for PIHM smiulations, the mesh file generated by PIHM-GIS is supper inposed on the GGSURGO data and from each trinagle the best representation of soil mapunits is extracted and from that the soil infomration required by PIHM. PIHM-GIS extracts centroid information, that is the mapunit that is located at the centroid of each trinagle. This is done for easiness and clarity. 
# ##### In this program we wil extract the map unit that is most frequent  (mode) in each trinagle based on GSSURGO raster pixel counts. This is expected to be more representative of the watershed conditions. To do that , the Zonal Statistics raster tool in GIS is used and the statistical mode for each triangle is selected.
# 
###########################################################################################################################






#### import the shape files from QGIS with the MUKEY mode from each triangle ####

########### Read infromation about the shape files ###########

# HansYoust.mesh.info<-ogrInfo("C:/Felipe/PIHM-CYCLES/PIHM/PIHM_Felipe/CNS/Manhantango/HydroTerreFullManhantango/HansYostDeepCreek/GSSURGO/HY_GSURGO.shp");

Project.mesh.info<-ogrInfo("C:/Aun Trabajo en Proceso/HansYostDeepCreek/Aug2920171550/3DomainDecomposition/DomainDecomposition2.shp")  ;  

#### read the shape file that has been created in QGIS using the zonal statistics

# HansYoust.GSSURGO<-readOGR("C:/Felipe/PIHM-CYCLES/PIHM/PIHM_Felipe/CNS/Manhantango/HydroTerreFullManhantango/HansYostDeepCreek/GSSURGO/HY_GSURGO.shp")  ;

Project.GSSURGO<-readOGR("C:/Aun Trabajo en Proceso/HansYostDeepCreek/Aug2920171550/3DomainDecomposition/DomainDecomposition2.shp")  ;  

# str(HansYoust.GSSURGO) ;

str(Project.GSSURGO, max.level = 3) ;


#plot(HansYoust.GSSURGO);

plot(Project.GSSURGO) ;


#str(HansYoust.GSSURGO@data) ;

str(Project.GSSURGO@data)  ; 

#### Extract the Mukeys corresponding to the mode in each mesh triangle


# HansYoust.GSSURGO@data$MUKEYS.mode<-as.factor(HansYoust.GSSURGO@data$SSURGO_mod) ;

Project.GSSURGO@data$MUKEYS.mode<-as.factor(Project.GSSURGO@data$Mukey_majo) ;


#MUKEYS<-levels(HansYoust.GSSURGO@data$MUKEYS.mode)  ;

MUKEYS<-levels(Project.GSSURGO@data$MUKEYS.mode)  ;

str(MUKEYS)  ;



#HansYoust.GSSURGO@data$MUKEYS.index<-HansYoust.GSSURGO@data$MUKEYS.mode ;

Project.GSSURGO@data$MUKEYS.index<-Project.GSSURGO@data$MUKEYS.mode ;



MUKEYS.INDX<-levels(Project.GSSURGO@data$MUKEYS.index)<-seq(1:length(levels(Project.GSSURGO@data$MUKEYS.index))) ;

MUKEYS.map.1<-Project.GSSURGO@data[,c('Ele_ID', 'MUKEYS.mode', 'MUKEYS.index')]  ;

MUKEYS.map.2<-data.frame(MUKEYS.INDX,MUKEYS) ;

str(MUKEYS.map.1)

str(MUKEYS.map.2)


paste0(inputfile.name, '.ATT')

write.table(MUKEYS.map.1,file=paste0(inputfile.name, '_MUKEYS_MAP.txt'), row.names=F , quote=F, sep = "\t") ;

write.table(MUKEYS.map.2,file=paste0(inputfile.name, '_MUKEYS_INDX.txt'), row.names=F , quote=F, sep = "\t") ;

################################ Query the Soil Data access database with SQL through R #################


# from https://sdmdataaccess.sc.egov.usda.gov/queryhelp.aspx
# and https://sdmdataaccess.sc.egov.usda.gov/documents/ReturningSoilTextureRelatedAttributes.pdf


# --Sample query begins.
# --Note that a pair of dashes denotes the beginning of a comment. 
# SELECT
# saversion, saverest, -- attributes from table "sacatalog"
# l.areasymbol, l.areaname, l.lkey, -- attributes from table "legend"
# musym, muname, museq, mu.mukey, -- attributes from table "mapunit"
# comppct_r, compname, localphase, slope_r, c.cokey, -- attributes from table "component"
# hzdept_r, hzdepb_r, ch.chkey, -- attributes from table "chorizon"
# sandtotal_r, silttotal_r, claytotal_r, --total sand, silt and clay fractions from table "chorizon"
# sandvc_r, sandco_r, sandmed_r, sandfine_r, sandvf_r,--sand sub-fractions from table "chorizon"
# texdesc, texture, stratextsflag, chtgrp.rvindicator, -- attributes from table "chtexturegrp"
# texcl, lieutex, -- attributes from table "chtexture"
# texmod -- attributes from table "chtexturemod"
# FROM sacatalog sac
# INNER JOIN legend l ON l.areasymbol = sac.areasymbol AND l.areatypename = 'Non-MLRA Soil Survey Area'
# INNER JOIN mapunit mu ON mu.lkey = l.lkey
# AND mu.mukey IN
# ('107559','107646','107674','107682','107707','107794','107853','107854','107865','107867','107869','107870','107871')
# LEFT OUTER JOIN component c ON c.mukey = mu.mukey
# LEFT OUTER JOIN chorizon ch ON ch.cokey = c.cokey
# LEFT OUTER JOIN chtexturegrp chtgrp ON chtgrp.chkey = ch.chkey
# LEFT OUTER JOIN chtexture cht ON cht.chtgkey = chtgrp.chtgkey
# LEFT OUTER JOIN chtexturemod chtmod ON chtmod.chtkey = cht.chtkey
# --WHERE.
# --ORDER BY l.areaname, museq, comppct_r DESC, compname, hzdept_r -- standard soil report ordering
# --Sample query ends. 

# extract the map unit keys from the RAT, and format for use in an SQL IN-statement
#in.statement2 <- format_SQL_in_statement(MUKEYS$ID); 

in.statement2 <- format_SQL_in_statement(MUKEYS); 


# format query in SQL- raw data are returned

Pedon.query<- paste0("SELECT component.mukey, component.cokey, compname, comppct_r, majcompflag, slope_r, hzdept_r, hzdepb_r,hzthk_r, hzname, awc_r, sandtotal_r, silttotal_r, claytotal_r, om_r,dbtenthbar_r, dbthirdbar_r, dbfifteenbar_r, fraggt10_r, frag3to10_r, sieveno10_r, sieveno40_r, sieveno200_r, ksat_r  FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement2," ORDER BY mukey, comppct_r DESC, hzdept_r ASC") ;

# now get component and horizon-level data for these map unit keys
Pedon.info<- SDA_query(Pedon.query);
head(Pedon.info) ;
str(Pedon.info)  ;

# filter components that are the major components of each unit map with the Flag majcompflag=='Yes'

Pedon.info.MajorC<-Pedon.info[which(Pedon.info$majcompflag == 'Yes'),]  ;
head(Pedon.info.MajorC) ; 
str(Pedon.info.MajorC)  ;



# check if there are mukeys with more than one dominant component

Pedon.info.MajorC$mukey.factor<-as.factor(Pedon.info.MajorC$mukey) ;

str(Pedon.info.MajorC$mukey.factor)


Pedon.info.MajorC$mukey_comppct_r<-paste(Pedon.info.MajorC$mukey.factor,Pedon.info.MajorC$comppct_r, sep = "_") ;

# Select major component mukeys that have also the highest component percent comppct_r

head(Pedon.info.MajorC)  ;

Dominant<- aggregate(comppct_r ~ mukey.factor, data=Pedon.info.MajorC, FUN="max" , drop=T, simplify=T) ;

head(Dominant)  ;

str(Dominant) ;

Dominant$mukey_comppct_r<-paste(Dominant$mukey.factor,Dominant$comppct_r, sep ="_");


Mukey.Pedon<-Pedon.info.MajorC[Pedon.info.MajorC$mukey_comppct_r %in% Dominant$mukey_comppct_r,]  ;

str(Mukey.Pedon) ;


# Creating Mukey ID for each dominant component


Mukey.Pedon$mukey_ID<-as.character(Mukey.Pedon$mukey) ;


str(Mukey.Pedon);


#  Transform the Pedon.info query in to the right format to be converted into a SoilProfileCollection object
#   https://ncss-tech.github.io/AQP/aqp/aqp-intro.html


#Pedon.info$id<-Pedon.info$mukey ;
# Pedon.info$top<-Pedon.info$hzdept_r ;
# Pedon.info$bottom<-Pedon.info$hzdept_r ;
#Pedon.info$name<-Pedon.info$hzname ;

depths(Mukey.Pedon)<-mukey_ID ~ hzdept_r + hzdepb_r  ;
str(Mukey.Pedon) ;


plot(Mukey.Pedon, name='hzname',color='dbthirdbar_r')  ;


# Add soil profile depth  soil.depth



Mukey.Pedon$soil.depth<-profileApply(Mukey.Pedon, FUN=max) ; 


Mukey.Pedon$hzthickns_r<-Mukey.Pedon$hzdepb_r-Mukey.Pedon$hzdept_r  ;

str(Mukey.Pedon) ;

# add total soil depth to each horizon

Mukey.Pedon@horizons<-merge(Mukey.Pedon@horizons, Mukey.Pedon@site, by.x='mukey', by.y='mukey_ID') ;


str(Mukey.Pedon) ;

# # Add soil thickness x soil bulk density / soil.depth (hzthickns_r *dbthirdbar_r)/soil.depth to estimate weight average clay,silt sand content
# 
# Mukey.Pedon$hzthickns_dbthirdbar_soil.depth<-(Mukey.Pedon$hzthickns_r*Mukey.Pedon$dbthirdbar_r)/Mukey.Pedon@horizons$soil.depth  ;
# 
# str(Mukey.Pedon) ;
# 
# 



######### Use the slice tool to divide the horizons into 1 cm layers and sum the components (clay, sand, silt) multiplied by 
#########  the thincknes (1cm) and the bulk density dbthirdbar_r to obtain the wieghted clay, sand, etc for pihm



sliced<-aqp::slice(Mukey.Pedon, fm = 0:max(Mukey.Pedon) ~ sandtotal_r + silttotal_r + claytotal_r + om_r + dbthirdbar_r  + soil.depth + mukey.factor ) ;

plot(sliced, name='hzname', color='om_r') ;

str(sliced) ;



# sliced2<-aqp::slice(Mukey.Pedon[1:10], fm = seq(0,max(Mukey.Pedon),by=10) ~ sandtotal_r + silttotal_r + claytotal_r + om_r + dbthirdbar_r) ;
# 
# sliced2@horizons$hzdepb_r<-sliced2@horizons$hzdept_r+10





######   multiply the thincknes (1cm) and the bulk density dbthirdbar_r to the component percentage to obtain the weighted component

##### sum the weighted component 1 cm layers  to obtained the weighted average component


sliced@site$SOIL_MASS<- profileApply(sliced, FUN=function(x) sum(x$dbthirdbar_r, na.rm=T), simplify = T) ;

sliced@site$SANDMASS<- profileApply(sliced, FUN=function(x) sum((x$sandtotal_r*x$dbthirdbar_r)/100, na.rm=T), simplify = T) ;

sliced@site$SILTMASS<- profileApply(sliced, FUN=function(x) sum((x$silttotal_r*x$dbthirdbar_r)/100, na.rm=T), simplify = T) ;

sliced@site$CLAYMASS<- profileApply(sliced, FUN=function(x) sum((x$claytotal_r*x$dbthirdbar_r)/100, na.rm=T), simplify = T) ;

sliced@site$OM_MASS<- profileApply(sliced, FUN=function(x) sum((x$om_r*x$dbthirdbar_r)/100, na.rm=T), simplify = T) ;


sliced@site$SAND<-(sliced@site$SANDMASS/sliced@site$SOIL_MAS)*100   ;

sliced@site$SILT<-(sliced@site$SILTMASS/sliced@site$SOIL_MAS)*100   ;

sliced@site$CLAY<-(sliced@site$CLAYMASS/sliced@site$SOIL_MAS)*100   ;

sliced@site$TEXTURE_CHECK<-sliced@site$SAND + sliced@site$SILT + sliced@site$CLAY ;


sliced@site$OM<- (sliced@site$OM_MASS/sliced@site$SOIL_MAS)*100   ;

sliced@site$BULKD<-sliced@site$SOIL_MASS/sliced@site$soil.depth ;



head(sliced@site)


####### write the soils data in a format that PIHM can read trough the Data model Loader step in PIHM-GIS
####### include an index to replace the MUKEY with the indexs, as PIHM does not read the MUKEYS and needs an integer index instead



# HansYoust_Soil<-merge(sliced@site[, c("mukey_ID", "SILT", "CLAY" , "OM" , "BULKD")], MUKEYS.map.2, by.x='mukey_ID', by.y='MUKEYS', all=T) ;

Project_Soil<-merge(sliced@site[, c("mukey_ID", "SILT", "CLAY" , "OM" , "BULKD")], MUKEYS.map.2, by.x='mukey_ID', by.y='MUKEYS', all=T) ;



# HansYoust_Soil[,c("SILT", "CLAY" , "OM" , "BULKD")]<-signif(HansYoust_Soil[,c("SILT", "CLAY" , "OM" , "BULKD")], digits=4)

Project_Soil[,c("SILT", "CLAY" , "OM" , "BULKD")]<-signif(HansYoust_Soil[,c("SILT", "CLAY" , "OM" , "BULKD")], digits=4) ;

# names(HansYoust_Soil)<-c('MUKEY','SILT',  'CLAY',	'OM',	'BD', 'INDEX'); 

names(Project_Soil)<-c('MUKEY','SILT',  'CLAY',	'OM',	'BD', 'INDEX') ;

str(Project_Soil) ;

head(Project_Soil) ;


##### Adding the additional columns for the new PIHM-MM module inputs

# HansYoust_Soil$KINF<-HansYoust_Soil$KSATV<-HansYoust_Soil$KSATH<-HansYoust_Soil$MAXSMC<-HansYoust_Soil$MINSMC<-HansYoust_Soil$ALPHA<-HansYoust_Soil$BETA<-HansYoust_Soil$MACHF<-HansYoust_Soil$MACVF<-HansYoust_Soil$DMAC<-HansYoust_Soil$QTZ<- -999 ;

Project_Soil$KINF<-Project_Soil$KSATV<-Project_Soil$KSATH<-Project_Soil$MAXSMC<-Project_Soil$MINSMC<-Project_Soil$ALPHA<-Project_Soil$BETA<-Project_Soil$MACHF<-Project_Soil$MACVF<-Project_Soil$DMAC<-Project_Soil$QTZ<- -999 ;

##########################################################################################################################
##
## some of the dominant components Mukeys do no have data available. The strategy to fill these gaps is to gte the average of the Mukeys parameters of the neighboring Triangles.
##
##########################################################################################################################

# HansYoust_Soil_NA<-data.frame(which(is.na(HansYoust_Soil), arr.ind=T)) ;


Project_Soil_NA<-data.frame(which(is.na(HansYoust_Soil), arr.ind=T)) ;


# Mukey_Gaps<-HansYoust_Soil[unique(HansYoust_Soil_NA$row),'MUKEY'] ;


Mukey_Gaps<-Project_Soil[unique(Project_Soil_NA$row),'MUKEY'] ;

##### Find the soil index  and the triangles that have Mukeys corresponding to the Mukey_Gaps

Mukey_Gaps_indx<-MUKEYS.map.1[MUKEYS.map.1$MUKEYS.mode ==Mukey_Gaps, ]    ;


###### Find the neighboring triangles of the Triangles with the Mukey_Gaps 


Mukey_Gaps_indx_neighbors<-mesh.Elements[mesh.Elements$Index %in% Mukey_Gaps_indx$Ele_ID,]   ;


###### retrieve the representative mukeys of the neighboring triangles

Neighbor_Mukeys_1<-unlist(Mukey_Gaps_indx_neighbors[1,c('Nabr.0' , 'Nabr.1' , 'Nabr.2')],use.names = F, recursive=T)  ;

Neighbor_Mukeys<-MUKEYS.map.1[MUKEYS.map.1$Ele_ID %in% Neighbor_Mukeys_1, ]  ;

# Neighbor_Mukeys_para<-HansYoust_Soil[HansYoust_Soil$MUKEY %in% Neighbor_Mukeys$MUKEYS.mode, c('SILT' , 'CLAY' , 'OM' ,  'BD') ]  ;

Neighbor_Mukeys_para<-Project_Soil[Project_Soil$MUKEY %in% Neighbor_Mukeys$MUKEYS.mode, c('SILT' , 'CLAY' , 'OM' ,  'BD') ]  ;

######## Average the representative Mukeys properties  of the neighboring triangles

Neighbor_Mukeys_avg<-apply(Neighbor_Mukeys_para, MARGIN = c(2), FUN = 'mean') ;


####### Replace the values in the table 

# HansYoust_Soil[HansYoust_Soil$MUKEY == Mukey_Gaps,c('SILT' , 'CLAY' , 'OM' ,  'BD') ] <-Neighbor_Mukeys_avg ;

Project_Soil[Project_Soil$MUKEY == Mukey_Gaps,c('SILT' , 'CLAY' , 'OM' ,  'BD') ] <-Neighbor_Mukeys_avg ;

######## Need to replace the other triangles that have the same mukey

Neighbor_Mukeys_2<-unlist(Mukey_Gaps_indx_neighbors[2,c('Nabr.0' , 'Nabr.1' , 'Nabr.2')],use.names = F, recursive=T)  ;

Neighbor_Mukeys<-MUKEYS.map.1[MUKEYS.map.1$Ele_ID %in% Neighbor_Mukeys_2, ]    ;

# Neighbor_Mukeys_para<-HansYoust_Soil[HansYoust_Soil$MUKEY %in% Neighbor_Mukeys$MUKEYS.mode, c('SILT' , 'CLAY' , 'OM' ,  'BD') ]  ;

Neighbor_Mukeys_para<-Project_Soil[Project_Soil$MUKEY %in% Neighbor_Mukeys$MUKEYS.mode, c('SILT' , 'CLAY' , 'OM' ,  'BD') ]  ;

######## Average the representative Mukeys properties  of the neighboring triangles

Neighbor_Mukeys_avg<-apply(Neighbor_Mukeys_para, MARGIN = c(2), FUN = 'mean') ;

# HansYoust_Soil[dim(HansYoust_Soil)[1]+1,'INDEX']<-dim(HansYoust_Soil)[1]+1  ;

Project_Soil[dim(Project_Soil)[1]+1,'INDEX']<-dim(Project_Soil)[1]+1 

# HansYoust_Soil[dim(HansYoust_Soil)[1],c('SILT' , 'CLAY' , 'OM' ,  'BD')]<-Neighbor_Mukeys_avg ;

Project_Soil[dim(Project_Soil)[1],c('SILT' , 'CLAY' , 'OM' ,  'BD')]<-Neighbor_Mukeys_avg ;


# HansYoust_Soil[dim(HansYoust_Soil)[1],!names(HansYoust_Soil) %in% c( 'MUKEY' ,'SILT' , 'CLAY' , 'OM' ,  'BD', 'INDEX')] <- -999   ;

Project_Soil[dim(Project_Soil)[1],!names(Project_Soil) %in% c( 'MUKEY' ,'SILT' , 'CLAY' , 'OM' ,  'BD', 'INDEX')] <- -999   ;




# ###########################################################################################################################
# 
# ###     Prepare the Geology data for PIHM based on the properties of the depest layer of the horizon
# ###     of the dominant components of each map unit selected by the procedure used for soils data
# 
# ###########################################################################################################################


Mukey.deepest<-Mukey.Pedon@horizons[Mukey.Pedon@horizons$hzdepb_r == Mukey.Pedon@horizons$soil.depth,]  ;

str(Mukey.deepest) ;

# HansYoust_deepest<-Mukey.deepest [, c("mukey_ID", "silttotal_r", "claytotal_r" , "om_r" , "dbthirdbar_r")] ;

Project_deepest<-Mukey.deepest [, c("mukey_ID", "silttotal_r", "claytotal_r" , "om_r" , "dbthirdbar_r")] ;



# names(HansYoust_deepest)<-c('MUKEY','SILT',  'CLAY',	'OM',	'BD'); 

names(Project_deepest)<-c('MUKEY','SILT',  'CLAY',	'OM',	'BD'); 

Mukey.deepest.NA<-Mukey.deepest[is.na(Mukey.deepest$claytotal_r),'mukey_ID']  ;

###    Some horizons do not have complete data for the deepest layer. Therefore the next step is to
### take the data from the layer inmediately above the deepest 



Mukey.deepest.2<-Mukey.Pedon@horizons[Mukey.Pedon@horizons$mukey_ID %in% Mukey.deepest.NA , ]; 


Mukey.deepest_1<-Mukey.deepest.2[which(Mukey.deepest.2$hzdepb_r == Mukey.deepest.2$soil.depth)-1, c("mukey_ID", "silttotal_r", "claytotal_r" , "om_r" , "dbthirdbar_r")] ;

names(Mukey.deepest_1)<-c('MUKEY','SILT',  'CLAY',	'OM',	'BD');


# HansYoust_deepest[HansYoust_deepest$MUKEY %in% Mukey.deepest.NA, ]<-Mukey.deepest_1  ;

Project_deepest[Project_deepest$MUKEY %in% Mukey.deepest.NA, ]<-Mukey.deepest_1  ;

# HansYoust_deepest[, c('SILT',  'CLAY',	'OM',	'BD')] <-signif(HansYoust_deepest[, c('SILT',  'CLAY',	'OM',	'BD')], digits=4);

Project_deepest[, c('SILT',  'CLAY',	'OM',	'BD')] <-signif(Project_deepest[, c('SILT',  'CLAY',	'OM',	'BD')], digits=4) ;

####### write the geology data in a format that PIHM can read trough the Data model Loader step in PIHM-GIS
####### include an index to replace the MUKEY with the index, as PIHM does not read the MUKEYS and needs an integer index instead


# HansYoust_Geology<-merge(HansYoust_deepest, MUKEYS.map.2, by.x='MUKEY', by.y='MUKEYS', all=T) ;

Project_Geology<-merge(Project_deepest, MUKEYS.map.2, by.x='MUKEY', by.y='MUKEYS', all=T) ;


# names(HansYoust_Geology)<-c('MUKEY','SILT',  'CLAY',	'OM',	'BD', 'INDEX'); 

names(Project_Geology)<-c('MUKEY','SILT',  'CLAY',	'OM',	'BD', 'INDEX'); 

str(Project_Geology) ;

head(Project_Geology)  ;

# NUMGEOL<-data.frame(c('NUMGEOL'), dim(HansYoust_Geology)[1]) ;

NUMGEOL<-data.frame(c('NUMGEOL'), dim(Project_Geology)[1]) ;

##### Adding the additional columns for the new PIHM-MM module inputs

# HansYoust_Geology$KINF<-HansYoust_Geology$KSATV<-HansYoust_Geology$KSATH<-HansYoust_Geology$MAXSMC<-HansYoust_Geology$MINSMC<-HansYoust_Geology$ALPHA<-HansYoust_Geology$BETA<-HansYoust_Geology$MACHF<-HansYoust_Geology$MACVF<-HansYoust_Geology$DMAC<-HansYoust_Geology$QTZ<- -999 ;

Project_Geology$KINF<-Project_Geology$KSATV<-Project_Geology$KSATH<-Project_Geology$MAXSMC<-Project_Geology$MINSMC<-Project_Geology$ALPHA<-Project_Geology$BETA<-Project_Geology$MACHF<-Project_Geology$MACVF<-Project_Geology$DMAC<-Project_Geology$QTZ<- -999 ;




################################################################################################################################
##
## some of the dominant components Mukeys do no have data vailable. The strategy to fill these gaps is to gte the average of the Mukeys parameters of the neighboring Triangles.
##
##########################################################################################################################



###### retrieve the representative mukeys of the neighboring triangles

# Neighbor_Mukeys_para<-HansYoust_Geology[HansYoust_Geology$MUKEY %in% Neighbor_Mukeys$MUKEYS.mode, c('SILT' , 'CLAY' , 'OM' ,  'BD') ]  ;

Neighbor_Mukeys_para<-Project_Geology[Project_Geology$MUKEY %in% Neighbor_Mukeys$MUKEYS.mode, c('SILT' , 'CLAY' , 'OM' ,  'BD') ] ;

######## Average the representative Mukeys properties  of the neighboring triangles

Neighbor_Mukeys_avg<-apply(Neighbor_Mukeys_para, MARGIN = c(2), FUN = 'mean') ;


####### Replace the values in the table 

# HansYoust_Geology[HansYoust_Geology$MUKEY == Mukey_Gaps,c('SILT' , 'CLAY' , 'OM' ,  'BD') ] <-Neighbor_Mukeys_avg ;

Project_Geology[Project_Geology$MUKEY == Mukey_Gaps,c('SILT' , 'CLAY' , 'OM' ,  'BD') ] <-Neighbor_Mukeys_avg ;

######## Need to replace the other triangles that have the same mukey

# Neighbor_Mukeys_para<-HansYoust_Geology[HansYoust_Geology$MUKEY %in% Neighbor_Mukeys$MUKEYS.mode, c('SILT' , 'CLAY' , 'OM' ,  'BD') ]  ;

Neighbor_Mukeys_para<-Project_Geology[Project_Geology$MUKEY %in% Neighbor_Mukeys$MUKEYS.mode, c('SILT' , 'CLAY' , 'OM' ,  'BD') ]  ;


######## Average the representative Mukeys properties  of the neighboring triangles

Neighbor_Mukeys_avg<-apply(Neighbor_Mukeys_para, MARGIN = c(2), FUN = 'mean') ;



# HansYoust_Geology[dim(HansYoust_Geology)[1]+1,'INDEX']<-dim(HansYoust_Geology)[1]+1  ;

Project_Geology[dim(Project_Geology)[1]+1,'INDEX']<-dim(Project_Geology)[1]+1  

# HansYoust_Geology[dim(HansYoust_Geology)[1],c('SILT' , 'CLAY' , 'OM' ,  'BD')]<-Neighbor_Mukeys_avg ;

Project_Geology[dim(Project_Geology)[1],c('SILT' , 'CLAY' , 'OM' ,  'BD')]<-Neighbor_Mukeys_avg ;


# HansYoust_Geology[dim(HansYoust_Geology)[1],!names(HansYoust_Geology) %in% c( 'MUKEY' ,'SILT' , 'CLAY' , 'OM' ,  'BD', 'INDEX')] <- -999   ;

Project_Geology[dim(Project_Geology)[1],!names(Project_Geology) %in% c( 'MUKEY' ,'SILT' , 'CLAY' , 'OM' ,  'BD', 'INDEX')] <- -999   ;




#############################################################################################################################
#
#
####################### Write the soil and geology data in the format approptiate for PIHM to take #############################

# NUMSOIL<-data.frame(c('NUMSOIL'), dim(HansYoust_Soil)[1]) ;

NUMSOIL<-data.frame(c('NUMSOIL'), dim(Project_Soil)[1]) ;


# NUMGEOL<-data.frame(c('NUMGEOL'), dim(HansYoust_Geology)[1]) ;

NUMGEOL<-data.frame(c('NUMGEOL'), dim(Project_Geology)[1]) ;


write.table(NUMSOIL,file=paste0(inputfile.name, '_Soil.txt'), row.names=F , quote=F, sep = "\t", col.names=F) ;

# write.table(HansYoust_Soil[, c('INDEX','SILT',  'CLAY',	'OM','BD', 'KINF', 'KSATV' , 'KSATH' , 'MAXSMC' , 'MINSMC' , 'ALPHA' , 'BETA' , 'MACHF' , 'MACVF' , 'DMAC', 'QTZ')],file=paste0(inputfile.name, '_Soil.txt'), row.names=F , quote=F, sep = "\t", append= T) ;

write.table(Project_Soil[, c('INDEX','SILT',  'CLAY',	'OM','BD', 'KINF', 'KSATV' , 'KSATH' , 'MAXSMC' , 'MINSMC' , 'ALPHA' , 'BETA' , 'MACHF' , 'MACVF' , 'DMAC', 'QTZ')],file=paste0(inputfile.name, '_Soil.txt'), row.names=F , quote=F, sep = "\t", append= T) ;

####################  Add DINF , KMACV_RO  and KMACH_RO  at the end of the soil file ################
# DINF (type: double, unit: m) A virtual top soil layer thickness across which infiltration is calculated.
# KMACV RO (type: double, unit: dimensionless) Ratio between vertical macropore hydraulic conduc-
#   tivity and vertical saturated infiltration hydraulic conductivity.
# KMACH RO (type: double, unit: dimensionless) Ratio between horizontal macropore hydraulic con-
#   ductivity and horizontal saturated hydraulic conductivity.

DINF_etc<-data.frame(c('DINF' , 'KMACV_RO', 'KMACH_RO'), c( 0.10, 100.0 , 1000.0 )) ;

write.table(DINF_etc,file=paste0(inputfile.name, '_Soil.txt'), row.names=F , col.names=F ,quote=F, sep = "\t", append= T) ;


# NUMGEOL<-data.frame(c('NUMGEOL'), dim(HansYoust_Geology)[1]) ;

NUMGEOL<-data.frame(c('NUMGEOL'), dim(Project_Geology)[1]) ;


# write.table(HansYoust_Geology[, c('INDEX','SILT',  'CLAY',	'OM','BD', 'KINF', 'KSATV' , 'KSATH' , 'MAXSMC' , 'MINSMC' , 'ALPHA' , 'BETA' , 'MACHF' , 'MACVF' , 'DMAC', 'QTZ')],file=paste0(inputfile.name, '_Geology.txt'), row.names=F , quote=F, sep = "\t", append= T) ;

write.table(Project_Geology[, c('INDEX','SILT',  'CLAY',	'OM','BD', 'KINF', 'KSATV' , 'KSATH' , 'MAXSMC' , 'MINSMC' , 'ALPHA' , 'BETA' , 'MACHF' , 'MACVF' , 'DMAC', 'QTZ')],file=paste0(inputfile.name, '_Geology.txt'), row.names=F , quote=F, sep = "\t", append= T) ;


write.table(DINF_etc, file=paste0(inputfile.name, '_Geology.txt'), row.names=F , quote=F, sep = "\t", col.names=F, append= T ) ;





# 
# ####################### done for now #################################################################################









# ###########################################################################################################################
# 
# ###     Prepare depth to bed rock data to be incorporated into the mesh file when a uniform soil profile depth
# ###     is not what is desired 
# 
# ###########################################################################################################################

##### Read the nodes and the corresponding Mukey from the TX file formed from Qgis


HansYoust.Nodes.Mukeys.info<-ogrInfo(paste0(RevisedOutputs.dir, 'NodesMukeys.shp'));


HansYoust.Nodes.Mukeys<-readOGR(paste0(RevisedOutputs.dir, 'NodesMukeys.shp'))  ;

str(HansYoust.Nodes.Mukeys)  ;



#### Extract the Mukeys corresponding to each Node


HansYoust.Nodes.Mukeys@data$Mukey.factor<-as.factor(HansYoust.Nodes.Mukeys$Mukeys) ;

head(HansYoust.Nodes.Mukeys@data) 

####  Convert the Mukeys into a factor and extract the levels of the factor to get the Mukeys from which we need soil 
####  bedrock information

NODE.MUKEYS<-levels(HansYoust.Nodes.Mukeys@data$Mukey.factor)  ;

str(NODE.MUKEYS)



################################ Query the Soil Data access database with SQL through R #################


# extract the map unit keys from the RAT, and format for use in an SQL IN-statement
#in.statement2 <- format_SQL_in_statement(MUKEYS$ID); 

in.statement3 <- format_SQL_in_statement(NODE.MUKEYS); 


# format query in SQL- raw data are returned

Pedon.Nodes.query<- paste0("SELECT component.mukey, component.cokey, compname, comppct_r, majcompflag, slope_r, hzdept_r, hzdepb_r,hzthk_r, hzname, awc_r, sandtotal_r, silttotal_r, claytotal_r, om_r,dbtenthbar_r, dbthirdbar_r, dbfifteenbar_r, fraggt10_r, frag3to10_r, sieveno10_r, sieveno40_r, sieveno200_r, ksat_r  FROM component JOIN chorizon ON component.cokey = chorizon.cokey AND mukey IN ", in.statement3," ORDER BY mukey, comppct_r DESC, hzdept_r ASC") ;

# now get component and horizon-level data for these map unit keys
Pedon.Nodes.info<- SDA_query(Pedon.Nodes.query);
head(Pedon.Nodes.info) ;
str(Pedon.Nodes.info)  ;

# filter components that are the major components of each unit map with the Flag majcompflag=='Yes'

Pedon.Nodes.info.MajorC<-Pedon.Nodes.info[which(Pedon.Nodes.info$majcompflag == 'Yes'),]  ;
head(Pedon.Nodes.info.MajorC) ; 
str(Pedon.Nodes.info.MajorC)  ;

# check if there are mukeys with more than one dominant component

Pedon.Nodes.info.MajorC$mukey.factor<-as.factor(Pedon.Nodes.info.MajorC$mukey) ;

Pedon.Nodes.info.MajorC$mukey_comppct_r<-paste(Pedon.Nodes.info.MajorC$mukey.factor,Pedon.Nodes.info.MajorC$comppct_r, sep = "_") ;

# Select major component mukeys that have also the highest component percent comppct_r

head(Pedon.Nodes.info.MajorC)  ;

Dominant.Nodes.Mukeys<- aggregate(comppct_r ~ mukey.factor, data=Pedon.Nodes.info.MajorC, FUN="max" , drop=T, simplify=T) ;

head(Dominant.Nodes.Mukeys)  ;

str(Dominant.Nodes.Mukeys) ;

Dominant.Nodes.Mukeys$mukey_comppct_r<-paste(Dominant.Nodes.Mukeys$mukey.factor,Dominant.Nodes.Mukeys$comppct_r, sep ="_");


Mukey.Nodes.Pedon<-Pedon.Nodes.info.MajorC[Pedon.Nodes.info.MajorC$mukey_comppct_r %in% Dominant.Nodes.Mukeys$mukey_comppct_r,]  ;

str(Pedon.Nodes.info.MajorC$mukey_comppct_r)

str(Dominant.Nodes.Mukeys$mukey_comppct_r)
str(Mukey.Nodes.Pedon) ;


# Creating Mukey ID for each dominant component


Mukey.Nodes.Pedon$mukey_ID<-as.character(Mukey.Nodes.Pedon$mukey) ;


#  Transform the Pedon.info query in to the right format to be converted into a SoilProfileCollection object
#   https://ncss-tech.github.io/AQP/aqp/aqp-intro.html


#Pedon.info$id<-Pedon.info$mukey ;
# Pedon.info$top<-Pedon.info$hzdept_r ;
# Pedon.info$bottom<-Pedon.info$hzdept_r ;
#Pedon.info$name<-Pedon.info$hzname ;

depths(Mukey.Nodes.Pedon)<-mukey_ID ~ hzdept_r + hzdepb_r  ;
str(Mukey.Nodes.Pedon) ;






plot(Mukey.Nodes.Pedon, name='hzname',color='dbthirdbar_r')  ;


# get the total soil depth for each horizon


Mukey.Nodes.Pedon$soil.depth<-profileApply(Mukey.Nodes.Pedon, FUN=max) ; 


Mukey.Nodes.Pedon$hzthickns_r<-Mukey.Nodes.Pedon$hzdepb_r-Mukey.Nodes.Pedon$hzdept_r  ;

str(Mukey.Nodes.Pedon) ;

# add total soil depth to each horizon

Mukey.Nodes.Pedon@horizons<-merge(Mukey.Nodes.Pedon@horizons, Mukey.Nodes.Pedon@site, by.x='mukey', by.y='mukey_ID') ;


str(Mukey.Nodes.Pedon) ;


####### Merge the information of of each mukey soil depth from Gssurgo with each node with the corresponding Mukey


head(Mukey.Nodes.Pedon@horizons)

str(Mukey.Nodes.Pedon@horizons)

head(HansYoust.Nodes.Mukeys)

str(HansYoust.Nodes.Mukeys)

HansYoust.Nodes<-merge(HansYoust.Nodes.Mukeys@data , Mukey.Nodes.Pedon@site, by.x='Mukey.factor', by.y='mukey_ID') ;

HansYoust.Nodes$ZMIN.GSSURGO<-HansYoust.Nodes$ZMAX - (HansYoust.Nodes$soil.depth/100)



################################################################################################################################
##
## some of the dominant components Mukeys do no have data vailable. The strategy to fill these gaps is to get the average of the soil dpeth  of the neighboring nodes.
##
#########################################################################################################################

HansYoust.Nodes_NA<-data.frame(which(is.na(HansYoust.Nodes), arr.ind=T)) ;


######
# ####################### done for now #################################################################################





